name: New Post Notification

on:
  push:
    paths:
      - 'data/blog/**/*.mdx'  # 블로그 글 파일 변경 감지
    branches:
      - main

jobs:
  notify-new-post:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # 이전 커밋과 비교하기 위해

      - name: Check for new blog posts
        id: check_new_posts
        run: |
          echo "새로 추가된 블로그 글 확인 중..."
          
          # 최근 커밋에서 새로 추가되거나 수정된 MDX 파일 확인
          NEW_FILES=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD | grep "^data/blog/.*\.mdx$" || true)
          
          if [ -z "$NEW_FILES" ]; then
            echo "새로 추가되거나 수정된 MDX 파일이 없습니다."
            echo "has_new_posts=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "발견된 파일들:"
          echo "$NEW_FILES"
          
          JSON_OBJECTS=""
          
          # 각 파일에 대해 처리
          for file in $NEW_FILES; do
            echo "파일 처리 중: $file"
            
            if [ ! -f "$file" ]; then
              echo "파일이 존재하지 않습니다: $file"
              continue
            fi
            
            # frontmatter에서 draft 상태 확인
            DRAFT_STATUS=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^draft:" | sed 's/draft: *//' | tr -d ' ')
            
            # draft가 true이면 스킵
            if [ "$DRAFT_STATUS" = "true" ]; then
              echo "초안 상태입니다. 스킵: $file"
              continue
            fi
            
            # 메타데이터 추출
            TITLE=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^title:" | sed "s/title: *//" | sed "s/['\"]//g")
            DATE=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^date:" | sed "s/date: *//" | sed "s/['\"]//g")
            SUMMARY=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^summary:" | sed "s/summary: *//" | sed "s/['\"]//g")
            TAGS=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^tags:" | sed "s/tags: *//" | tr -d "[]'" | sed "s/,/, /g")
            
            # 파일명에서 slug 추출
            SLUG=$(basename "$file" .mdx)
            
            echo "제목: $TITLE"
            echo "날짜: $DATE"
            echo "요약: $SUMMARY"
            echo "태그: $TAGS"
            echo "슬러그: $SLUG"
            
            # JSON 객체 생성
            JSON_OBJ=$(jq -n \
              --arg title "$TITLE" \
              --arg date "$DATE" \
              --arg summary "$SUMMARY" \
              --arg tags "$TAGS" \
              --arg slug "$SLUG" \
              --arg file "$file" \
              '{
                title: $title,
                date: $date,
                summary: $summary,
                tags: $tags,
                slug: $slug,
                file: $file
              }')
            
            if [ -z "$JSON_OBJECTS" ]; then
              JSON_OBJECTS="$JSON_OBJ"
            else
              JSON_OBJECTS="$JSON_OBJECTS"$'\n'"$JSON_OBJ"
            fi
          done

          if [ -z "$JSON_OBJECTS" ]; then
            echo "발행 가능한 새 글이 없습니다 (모두 초안)."
            echo "has_new_posts=false" >> $GITHUB_OUTPUT
          else
            # 모든 JSON 객체를 하나의 배열로 합치고 최종 payload로 래핑 (컴팩트 모드)
            FINAL_PAYLOAD=$(echo "$JSON_OBJECTS" | jq -c -s '{"posts": .}')
            
            echo "생성된 최종 페이로드:"
            echo "$FINAL_PAYLOAD"

            echo "has_new_posts=true" >> $GITHUB_OUTPUT
            echo "final_payload<<EOF" >> $GITHUB_OUTPUT
            echo "$FINAL_PAYLOAD" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Store new post info to KV
        if: steps.check_new_posts.outputs.has_new_posts == 'true'
        env:
          PAYLOAD: ${{ steps.check_new_posts.outputs.final_payload }}
        run: |
          echo "새 글 정보를 KV에 저장 중..."
          echo "전달받은 페이로드:"
          echo "$PAYLOAD"
          
          # KV에 새 글 정보 저장
          RESPONSE=$(curl -s -w "%{http_code}" -X POST "${{ secrets.DEPLOYMENT_URL || 'https://frogsoo.vercel.app' }}/api/kv/store-new-post" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.WEBHOOK_SECRET }}" \
            -d "$PAYLOAD" \
            -o response_body.txt)
          
          HTTP_CODE="${RESPONSE: -3}"
          RESPONSE_BODY=$(cat response_body.txt)
          
          echo "HTTP 응답 코드: $HTTP_CODE"
          echo "응답 내용: $RESPONSE_BODY"
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "✅ KV에 새 글 정보가 성공적으로 저장되었습니다!"
          else
            echo "❌ KV 저장 실패 (HTTP $HTTP_CODE)"
            echo "$RESPONSE_BODY"
            exit 1
          fi

      - name: Trigger Vercel Build Hook
        if: steps.check_new_posts.outputs.has_new_posts == 'true'
        run: |
          echo "Vercel Build Hook 트리거 중..."
          
          # Vercel Build Hook 호출
          RESPONSE=$(curl -s -w "%{http_code}" -X POST "${{ secrets.VERCEL_BUILD_HOOK_URL }}" \
            -o hook_response.txt)
          
          HTTP_CODE="${RESPONSE: -3}"
          RESPONSE_BODY=$(cat hook_response.txt)
          
          echo "HTTP 응답 코드: $HTTP_CODE"
          echo "응답 내용: $RESPONSE_BODY"
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "✅ Vercel Build Hook이 성공적으로 트리거되었습니다!"
          else
            echo "❌ Build Hook 트리거 실패 (HTTP $HTTP_CODE)"
            echo "$RESPONSE_BODY"
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.check_new_posts.outputs.has_new_posts }}" == "true" ]; then
            echo "📧 새 블로그 글 정보를 KV에 저장하고 배포를 트리거했습니다."
          else
            echo "📝 새로 추가된 발행 가능한 블로그 글이 없습니다."
          fi